/***************************************************************************
                     htmlgenerator.cpp  -  description
                             -------------------

    copyright            : (C) 2007-2015 by Andre Simon
    email                : andre.simon1@gmx.de
 ***************************************************************************/

/*
This file is part of ANSIFilter.

ANSIFilter is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

ANSIFilter is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with ANSIFilter.  If not, see <http://www.gnu.org/licenses/>.
*/

#include <fstream>
#include <iostream>
#include <sstream>

#include "htmlgenerator.h"
#include "version.h"

namespace ansifilter
{

HtmlGenerator::HtmlGenerator ():
    CodeGenerator(HTML),
    fileSuffix(".html")
{
    newLineTag="\n";
    styleCommentOpen="/*";
    styleCommentClose="*/";
    spacer=" ";
}

string HtmlGenerator::getOpenTag()
{
    ostringstream fmtStream;

    if (elementStyle.isBold()) {
        fmtStream<< "font-weight:bold;";
    }
    if (elementStyle.isItalic()) {
        fmtStream<< "font-style:italic;";
    }
    if (elementStyle.isBlink()) {
        fmtStream<< "text-decoration:blink;";
    }
    if (elementStyle.isUnderline()) {
        fmtStream<< "text-decoration:underline;";
    }
    if (elementStyle.isConceal()) {
        fmtStream<< "display:none;";
    }

    if (elementStyle.isFgColorSet()) {
        fmtStream << "color:#"
                  << elementStyle.getFgColour().getRed(HTML)
                  << elementStyle.getFgColour().getGreen(HTML)
                  << elementStyle.getFgColour().getBlue(HTML)
                  << ";";
    }

    if (elementStyle.isBgColorSet()) {
        fmtStream <<"background-color:#"
                  << elementStyle.getBgColour().getRed(HTML)
                  << elementStyle.getBgColour().getGreen(HTML)
                  << elementStyle.getBgColour().getBlue(HTML)
                  <<";";
    }

    string fmt  = fmtStream.str();
    tagIsOpen = fmt.size()>0;
    if (tagIsOpen) {
        ostringstream spanTag;
        spanTag<< "<span style=\""<<fmt<<"\">";
        return spanTag.str();
    }
    return "";
}

string HtmlGenerator::getCloseTag()
{
    string retVal = tagIsOpen ? "</span>"  : "";
    tagIsOpen = false;
    return retVal;
}

string HtmlGenerator::getGeneratorComment()
{
    ostringstream s;
    s <<"\n</body>\n</html>\n<!--HTML generated by ansifilter "
      << ANSIFILTER_VERSION << ", " <<  ANSIFILTER_URL <<"-->\n";

    return s.str();
}

string HtmlGenerator::getHeader()
{
    ostringstream os;
    os << "<!DOCTYPE html>"
       << "\n<html>\n<head>\n";
    if (encodingDefined()) {
        os << "<meta charset=\""
           << encoding
           << "\">\n";
    }
    if (!styleSheetPath.empty()) {
        os << "<link rel=\"stylesheet\" type=\"text/css\" href=\""
           << styleSheetPath << "\">\n";
    }
    os << "<title>" << docTitle << "</title>\n";
    os << "</head>\n<body>\n";

    if (!styleSheetPath.empty()) {
        os << "<pre>";
    } else {
        os << "<pre style=\"";
        
        if (parseCP437) {
          os << "color: #e5e5e5;";
          os << "background-color: black;";
        }
        
        os << "font-family:"<< font << ";";
        os << "font-size:"<< fontSize << ";";
        os << "\">";
    }

    return os.str();
}

string HtmlGenerator::getFooter()
{
    string footer;
    footer += getCloseTag();
    footer += "</pre>" + getGeneratorComment();
    return footer;
}

void HtmlGenerator::printBody()
{
    processInput();
}

string HtmlGenerator::maskCharacter(unsigned char c)
{
    switch (c) {
    case '<' :
        return "&lt;";
        break;
    case '>' :
        return "&gt;";
        break;
    case '&' :
        return "&amp;";
        break;
    case '\"' :
        return "&quot;";
        break;
    case '\'' :
      return "&apos;";
      break;
    case '\t' : // see deletion of nonprintable chars below
        return "\t";
        break;

    case '@' :
        return "&#64;";
        break;
        
    default :
        if (c>0x1f ) { // printable?
            return string( 1, c );
        } else {
            return "";
        }
    }
}

string HtmlGenerator::maskCP437Character(unsigned char c)
{    
  switch (c) {
    case 0 :
      return " ";
      break;
      
    case '<' :
      return "&lt;";
      break;
    case '>' :
      return "&gt;";
      break;
    case '&' :
      return "&amp;";
      break;
    case '\"' :
      return "&quot;";
      break;
    case '\'' :
      return "&apos;";
      break;
    case '\t' : // see deletion of nonprintable chars below
      return "\t";
      break;
    
    case '\r' : // see deletion of nonprintable chars below
      return "\n";
      break;
      
    case '@' :
      return "&#64;";
      break;
      
      //shades
    case 0xb0:   
      return "&#9617;";
      break;
    case 0xb1:   
      return "&#9618;";
      break;
    case 0xb2:   
      return "&#9619;";
      break;
      
      //box drawings
    case 0xb3:   
      return "&#9474;";
      break;
    case 0xb4:   
      return "&#9508;";
      break;
    case 0xb5:   
      return "&#9569;";
      break;
    case 0xb6:   
      return "&#9570;";
      break;
    case 0xb7:   
      return "&#9558;";
      break;
    case 0xb8:   
      return "&#9557;";
      break;
    case 0xb9:   
      return "&#9571;";
      break;
    case 0xba:   
      return "&#9553;";
      break;
    case 0xbb:   
      return "&#9559;";
      break;
    case 0xbc:   
      return "&#9565;";
      break;
    case 0xbd:   
      return "&#9564;";
      break;
    case 0xbe:   
      return "&#9563;";
      break;
    case 0xbf:   
      return "&#9488;";
      break;
      
    case 0xc0:   
      return "&#9492;";
      break;
    case 0xc1:   
      return "&#9524;";
      break;
    case 0xc2:   
      return "&#9516;";
      break;
    case 0xc3:   
      return "&#9500;";
      break;
    case 0xc4:   
      return "&#9472;";
      break;
    case 0xc5:   
      return "&#9532;";
      break;
    case 0xc6:   
      return "&#9566;";
      break;
    case 0xc7:   
      return "&#9567;";
      break;
    case 0xc8:   
      return "&#9562;";
      break;
    case 0xc9:   
      return "&#9556;";
      break;
    case 0xca:   
      return "&#9577;";
      break;
    case 0xcb:   
      return "&#9574;";
      break;
    case 0xcc:   
      return "&#9568;";
      break;
    case 0xcd:   
      return "&#9552;";
      break;
    case 0xce:   
      return "&#9580;";
      break;
    case 0xcf:   
      return "&#9575;";
      break;
  
    case 0xd0:   
      return "&#9576;";
      break;
    case 0xd1:   
      return "&#9572;";
      break;
    case 0xd2:   
      return "&#9573;";
      break;
    case 0xd3:   
      return "&#9561;";
      break;
    case 0xd4:   
      return "&#9560;";
      break;
    case 0xd5:   
      return "&#9554;";
      break;
    case 0xd6:   
      return "&#9555;";
      break;
    case 0xd7:   
      return "&#9579;";
      break;
    case 0xd8:   
      return "&#9578;";
      break;
    case 0xd9:   
      return "&#9496;";
      break;
    case 0xda:   
      return "&#9484;";
      break;
    
      
      
      //https://de.wikipedia.org/wiki/Unicodeblock_Blockelemente
    case 0xdb:
      return "&#9608;";
      break;
    case 0xdc:
      return "&#9604;";
      break;
    case 0xdd:
      return "&#9612;";
      break;
    case 0xde:
      return "&#9616;";
      break;      
    case 0xdf:
      return "&#9600;";
      break;
   
    case 0xec:
      return "&infin;";
      break;
      
    case 0xfe:   
      return "&#9632;";
      break;
      
    case 0x9b:   
      return "&#x00a2;";
      break;
      
      
    
    case 0xf0:
      return "&#x2261;";
      break;
    
    case 0xf9:
      return "&#x2219;";
      break;
      
      
      
    case 0xfa:
      return "&#8226;";
      break;
    
    case 22:
    case 25:
    case 26:
      return " ";
      break;
      
    default :
        if (c>0x1f && c<0x7f) { // printable?          
          return string( 1, c );
        } else {
          std::cerr<<"Unknown: "<<(int)c<<"\n";
          return "";
        }
  }
};

void HtmlGenerator::insertLineNumber ()
{
    if ( showLineNumbers ) {

        ostringstream lnum;
        lnum << setw ( 5 ) << right;
        if( numberCurrentLine ) {
            *out << getCloseTag();
            lnum << lineNumber;
            *out << "<span";

            if (addAnchors) {
                *out << " id=\"l_" << lineNumber<< "\" ";
            }
            *out << " style=\"color:gray;\">";

            *out <<lnum.str() <<"</span> ";
            *out << getOpenTag();
        } else {
            *out << lnum.str(); //for indentation
        }
    }

}

}
